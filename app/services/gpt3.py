import json
import logging
import requests
from flask import request
from configparser import ConfigParser
#from app import app

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter('%(asctime)s [%(levelname)s] %(message)s'))
logger.addHandler(handler)
config = ConfigParser()
config.read('config/keys_config.cfg')
API_KEY = config.get('gpt3', 'api_key')


#@app.route("/gpt3", methods=["POST"])
def generate_text():
    """
    Endpoint that generates text based on the specified emotion.
    """
    try:
        # Extract the emotion from the request
        emotion = request.json['emotion']
        prompt = request.json['prompt']
        platform = request.json['platform'].lower()
        keywords = request.json.get('keywords', [])
        
        
        # Define the maximum length of the post for each platform
        platform_limits = {
            "facebook": (50, 260),
            "linkedin": (70, 350),
            "twitter": (25, 125),
        }
        
        if platform not in platform_limits:
            return "Error: unsupported platform", 400
        
        max_words, max_characters = platform_limits[platform]
               

        # Define the prompt based on the emotion
        emotion_map = {
            "funny": "Compose a humorous and entertaining comment, showcasing your wit and lightheartedness while still providing insightful thoughts on the topic and its impact on the industry or professionals",
            "serious": "Write a sincere and insightful comment, demonstrating your knowledge and understanding of the topic while offering a serious perspective on its impact on the industry or professionals",
            "sarcastic": "Create a witty and sarcastic comment, showcasing your sense of humor while still providing critical thoughts on the topic and its impact on the industry or professionals",
            "provocative": "Generate a provocative and thought-provoking comment, challenging conventional perspectives and encouraging discussion on the topic and its impact on the industry or professionals",
            "controversial": "Compose a controversial and bold comment, addressing a sensitive or divisive issue and presenting a unique perspective on the topic and its impact on the industry or professionals",
        }
        
        default_prompt = "Create a unique and thought-provoking comment, showcasing your creativity and knowledge of the topic while offering a positive outlook on its impact on the industry or professionals"
        
        if keywords:
            prompt = emotion_map.get(emotion.lower(), default_prompt)+" on the following post \n" + prompt + "\n based on these keywords: "+", ".join(keywords)  
        else:
            prompt = emotion_map.get(emotion.lower(), default_prompt)+" on the following post \n" + prompt 

        # Define the API key and the endpoint URL
        api_key = API_KEY
        model = "text-davinci-003"
        # url = f"https://api.openai.com/v1/engines/{model}/jobs"  depreciated
        url = "https://api.openai.com/v1/completions"
        

        # Define the headers for the API request
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
        
        
        # Define the data for the API request
        data = {
            "prompt": prompt,
            "model": model,
            "temperature": 0.9,
            "top_p": 1,
            "max_tokens": max_words,
            # "max_chars": max_characters,
            "presence_penalty": 0.8,
            "frequency_penalty": 0.7,             
            "n":1
        }

        # Send the API request
        # logger.info(f"prompt is: {prompt}")
        response = requests.post(url, headers=headers, data=json.dumps(data))
        hh=data['prompt']
        logger.info(f"prompt: {hh}")
        # Check if the request was successful
        if response.status_code != 200:
            hh=data['prompt']
            logger.info(f"prompt: {hh}")
            raise Exception(f"Error accessing OpenAI API, status code: {response.status_code}")

        # Extract the text generated by the API
        result = response.json()
        generated_text = result['choices'][0]['text']

        # Log a message indicating that text generation was successful
        logger.info(f"Generated text: {generated_text}")

        # Return the generated text
        return generated_text, 200

    except Exception as e:
        # Log an error message if an exception was raised
        logger.error(f"Error generating text: {str(e)}")

        # Return a 500 Internal Server Error response
        return "Error generating text", 500

if __name__ == "__main__":
    print("")